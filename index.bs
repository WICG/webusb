<pre class="metadata">
Title: WebUSB API
Status: w3c/CG-DRAFT
ED: https://wicg.github.io/webusb
Shortname: webusb
Level: 1
Editor: Reilly Grant 83788, Google LLC https://www.google.com, reillyg@google.com
Editor: Ken Rockot 87080, Google LLC https://www.google.com, rockot@google.com
Editor: Ovidio Ruiz-Henr√≠quez 106543, Google LLC https://www.google.com, odejesush@google.com
Abstract: This document describes an API for securely providing access to Universal Serial Bus devices from web pages.
Group: wicg
Repository: https://github.com/WICG/webusb/
!Participate: <a href="https://www.w3.org/community/wicg/">Join the W3C Community Group</a>
!Participate: <a href="irc://irc.w3.org:6665/#webusb">IRC: #webusb on W3C's IRC</a> (Stay around for an answer, it make take a while)
!Participate: <a href="http://stackoverflow.com/questions/tagged/webusb">Ask questions on StackOverflow</a>
</pre>

<style>
table {
  border-collapse: collapse;
  border-left-style: hidden;
  border-right-style: hidden;
  text-align: left;
}
table caption {
  font-weight: bold;
  padding: 3px;
  text-align: left;
}
table td, table th {
  border: 1px solid black;
  padding: 3px;
}
</style>

# Introduction # {#introduction}

<em>This section is non-normative</em>.

The Universal Serial Bus (USB) is the de-facto standard for wired peripherals.
Most USB devices implement one of roughly a dozen standard "device classes"
which specify a way for the device to advertise the features it supports and
commands and data formats for using those features. Standard device classes
include keyboard, mice, audio, video and storage devices. Operating systems
support such devices using the "class driver" provided by the OS vendor. There
is however a long tail of devices that do not fit into one of the standardized
device classes.  These devices require hardware vendors to write native drivers
and SDKs in order for developers to take advantage of them and this native code
prevents these devices from being used by the web.

The WebUSB API provides a way to safely expose USB device services to the web.
It provides an API familiar to developers who have used existing native USB
libraries and exposes the device interfaces defined by existing specifications.
With this API hardware manufacturers will have the ability to build
cross-platform JavaScript SDKs for their devices. This will be good for the web
because, instead of waiting for a new kind of device to be popular enough for
browsers to provide a specific API, new and innovative hardware can be built
for the web from day one.

For more information about USB see [[#appendix-intro]].

# Motivating Applications # {#motivating-applications}

<em>This section is non-normative</em>.

## Educational Devices ## {#app-edu-devices}

The software delivery model of the web is a key enabler for educational
applications because they can be quickly loaded on any computer without
questions of platform compatibility or administrative credentials. Science
classes are incorporating computerized measurement and data logging into their
lessons. These tools require bundled software that may be difficult to install
on managed computers as every new native application adds overhead to an already
stressed IT department. Web-based hardware APIs allow support for these devices
to be built directly into existing online course materials, providing a
completely seamless experience.

Students learning to code with one of the many microcontroller development kits
can take advantage of online developer tools to write and upload their code.
These tools already exist however they require a native component to interface
between the browser and the hardware. These native extensions add a barrier to
entry and may expose the user to security vulnerabilities in a way that that
code running in the sandboxed web environment does not.

## Web Drivers ## {#app-drivers}

The composablity of the web allows a new ecosystem of hardware support to be
built entirely from web technology. Taking 3D printers an example, imagine that
a site hosting 3D object designs wants to integrate printing directly into their
page. The web supports 2D printing but there is no API for the 3D variety. If
manufacturers host embeddable pages that use the WebUSB API to send data to
their printers, sites can use these pages to integrate support for the hardware
in the same way that features such as embedded maps are added to many existing
sites.

## Devices Updates and Diagnostics ## {#app-updates-and-diagnostics}

While wireless protocols such as Bluetooth are often the more convenient choice
for consumer devices USB ports continue to proliferate because they are an easy
solution for power delivery and can serve as the connection of last resort when
the device isn't working. By integrating update and diagnostic tools into their
support site a hardware manufacturer can provide tools for customers on any
platform and collect better diagnostic data when a customer reaches out for
support through their website. The <a>landing page</a> provides a way for the
device manufacturer to direct the user to the right part of their website for
help with their device.

# Security and Privacy Considerations # {#security-and-privacy}

<em>This section is non-normative</em>.

The WebUSB API is a powerful feature and has the possibility to expose users to
a number of new privacy and security risks. These risks can be broadly divided
into three categories that will be described in the sections below.

## Abusing Access to a Device ## {#abusing-a-device}

Peripheral devices can serve a number of purposes. They may store data, as a
flash drive does. They may collect information about the outside world as a
camera or microphone does. They may manipulate objects in the outside world as
a printer does. Each of the examples above have high-level APIs in the web
platform with security features that aim to prevent their abuse by a malicious
website. Storing data to or from an external drive requires the user to select
the file manually. Turning on the microphone or camera requires permission from
the user and may activate an indicator to let the user know data collection is
in progress. Printing a document requires explicit action as well. This API
provides a generic mechanism to connect to devices not covered by these
existing high-level APIs and so it requires a similarly generic mechanism for
preventing a malicious page from abusing a device.

The first of these protections is the {{USB/requestDevice()}} function. The UA
may display a permission prompt when this function is called. Even for a
non-malicious page this action also preserves user privacy by preventing a site
from connecting to a device before the user is aware that such a connection is
possible. The UA may also display an indicator when a device connection is
active.

Secondly, this specification requires that only secure contexts as described
in [[powerful-features]] can access USB devices. This ensures both the
authenticity of the code executing on behalf of the origin and that data read
from the device may not be intercepted in transit.

Lastly, since USB devices are unable to distinguish requests from multiple
sources, operating systems only allow a USB interface to have a single owning
user-space or kernel-space driver. The UA acts as a user-space driver, therefore
allowing only a single execution context to claim a USB interface at a time. The
{{USBDevice/claimInterface()}} function will fail if multiple execution contexts
attempt to claim an interface.

## Attacking a Device ## {#attacking-a-device}

Historically, unless they were created for high security applications, USB
devices have been designed to trust the host they are connected to and so the
host is the traditional guardian of access to the capabilities a device
provides. In the development of this specification two possibilities were
considered. First, the UA could notify the device of the origin from which a
request originated. This would be similar to the <code>Referrer</code> header
included in HTTP request. The difficulty of this approach is that it places
the burden of access control on the device. Devices often have very limited
processing and storage capabilities and so an effort was made to limit the
amount of work necessary on the part of the device.

The approach initially chosen during drafting of this specification was to
instead require that the UA control access though a mechanism similiar to
[[CORS]]. The device could provide the UA with a set of static data structures
defining a set of origins that are allowed to connect to it. To support a
transition period for existing devices it was proposed that information about
allowed origins could also be provided out of band through some kind of public
registry.

A downside of this approach was two-fold. First, it required vendors to build
new devices with WebUSB in mind or rely on a public registry system that proved
difficult to specify. Product development cycles are long and as only an
Editor's Draft this specification does not have the clout necessary to influence
product planning. Second, it provided no mechanism for third-party developers to
use this API with a device. This limited innovation and the number of developers
who could take advantage of this new capability.

After considering these options the authors have decided that the permission
prompt encouraged by the {{USB/requestDevice()}} method and the integration with
[[#feature-policy]] provide adequate protection against unwanted access to a
device.

## Attacking the Host ## {#attacking-the-host}

If a device is compromised then in addition to abusing its own capabilities
the attacker may also use it to in turn attack the host to which it is connected
or if the exploit is persistent any host it is connected to later. The methods
above are the ways in which this specification attempts to mitigate this attack
vector for once the device is under the control of an attacker (for example, by
uploading a malicious firmware image) there is nothing that can be done by the
UA to prevent further damage.

This specification recommends device manufacturers practice defense in depth by
designing their devices to only accept signed firmware updates and/or require
physical access to the device in order to apply some configuration changes.

# WebUSB Descriptors and Requests # {#webusb-descriptors-and-requests}

This specification defines descriptors and commands the UA MAY use to gather
information about the device specific to implementing this API.

<h3 dfn>WebUSB Platform Capability Descriptor</h3>

A device announces support for the WebUSB command set by including the
following <a>Platform Descriptor</a> in its <a>Binary Object
Store</a>:

<table>
  <tr>
    <th>Offset</th>
    <th>Field</th>
    <th>Size</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>0</td>
    <td>bLength</td>
    <td>1</td>
    <td>Number</td>
    <td>Size of this descriptor. Must be set to 24.</td>
  </tr>
  <tr>
    <td>1</td>
    <td>bDescriptorType</td>
    <td>1</td>
    <td>Constant</td>
    <td>DEVICE CAPABILITY descriptor type ([[!USB31]] Table 9-6).</td>
  </tr>
  <tr>
    <td>2</td>
    <td>bDevCapabilityType</td>
    <td>1</td>
    <td>Constant</td>
    <td>PLATFORM capability type ([[!USB31]] Table 9-14).</td>
  </tr>
  <tr>
    <td>3</td>
    <td>bReserved</td>
    <td>1</td>
    <td>Number</td>
    <td>This field is reserved and shall be set to zero.</td>
  </tr>
  <tr>
    <td>4</td>
    <td>PlatformCapabilityUUID</td>
    <td>16</td>
    <td>UUID</td>
    <td>Must be set to {3408b638-09a9-47a0-8bfd-a0768815b665}.</td>
  </tr>
  <tr>
    <td>20</td>
    <td>bcdVersion</td>
    <td>2</td>
    <td>BCD</td>
    <td>Protocol version supported. Must be set to 0x0100.</td>
  </tr>
  <tr>
    <td>22</td>
    <td>bVendorCode</td>
    <td>1</td>
    <td>Number</td>
    <td>bRequest value used for issuing WebUSB requests.</td>
  </tr>
  <tr>
    <td>23</td>
    <td>iLandingPage</td>
    <td>1</td>
    <td>Number</td>
    <td>URL descriptor index of the device's <a>landing page</a>.</td>
  </tr>
</table>

The <code>iLandingPage</code> field, when non-zero, indicates a
<dfn>landing page</dfn> which the device manufacturer would like the user to
visit in order to control their device. The UA MAY suggest the user navigate
to this URL when the device is connected.

Note: The USB is a little-endian bus and so according to [[RFC4122]] the UUID
above MUST be sent over the wire as the byte sequence <code>{0x38, 0xB6, 0x08,
0x34, 0xA9, 0x09, 0xA0, 0x47, 0x8B, 0xFD, 0xA0, 0x76, 0x88, 0x15, 0xB6,
0x65}</code>.

## WebUSB Device Requests ## {#device-requests}

All <a>control transfers</a> defined by this specification are considered to
be vendor-specific requests. The <code>bVendorCode</code> value found
in the <a>WebUSB Platform Capability Descriptor</a> provides the UA
with the <code>bRequest</code> the device expects the host to use when
issuing <a>control transfers</a> these requests. The request type is then
specified in the <code>wIndex</code> field.

<table>
  <caption>WebUSB Request Codes</caption>
  <tr>
    <th>Constant</th>
    <th>Value</th>
  </tr>
  <tr>
    <td>(Reserved)</td>
    <td>1</td>
  </tr>
  <tr>
    <td>GET_URL</td>
    <td>2</td>
  </tr>
</table>

<h4 dfn>Get URL</h4>

This request fetches the URL descriptor with the given index.

The device MUST respond with the <a>URL Descriptor</a> at the given
index or stall the transfer if the index is invalid.

<table>
  <tr>
    <th>bmRequestType</td>
    <th>bRequest</th>
    <th>wValue</th>
    <th>wIndex</th>
    <th>wLength</th>
    <th>Data</th>
  </tr>
  <tr>
    <td>11000000B</td>
    <td><code>bVendorCode</code></td>
    <td>Descriptor Index</td>
    <td>GET_URL</td>
    <td>Descriptor Length</td>
    <td>Descriptor</td>
  </tr>
</table>

## WebUSB Descriptors ## {#webusb-descriptors}

These descriptor types are returned by requests defined in this
specification.

<table>
  <caption>WebUSB Descriptor Types</caption>
  <tr>
    <th>Constant</th>
    <th>Value</th>
  </tr>
  <tr>
    <td>(Reserved)</td>
    <td>0-2</td>
  </tr>
  <tr>
    <td>WEBUSB_URL</td>
    <td>3</td>
  </tr>
</table>

<h4 dfn>URL Descriptor</h4>

This descriptor contains a single URL and is returned by the <a>Get URL</a>
request.

<table>
  <tr>
    <th>Offset</th>
    <th>Field</th>
    <th>Size</th>
    <th>Value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>0</td>
    <td>bLength</td>
    <td>1</td>
    <td>Number</td>
    <td>Size of this descriptor.</td>
  </tr>
  <tr>
    <td>1</td>
    <td>bDescriptorType</td>
    <td>1</td>
    <td>Constant</td>
    <td>WEBUSB_URL.</td>
  </tr>
  <tr>
    <td>2</td>
    <td>bScheme</td>
    <td>1</td>
    <td>Number</td>
    <td>URL scheme prefix.</td>
  </tr>
  <tr>
    <td>3</td>
    <td>URL</td>
    <td>Variable</td>
    <td>String</td>
    <td>UTF-8 encoded URL (excluding the scheme prefix).</td>
  </tr>
</table>

The <code>bScheme</code> field MUST be one of these values:

<table>
  <caption>URL Prefixes</caption>
  <tr>
    <th>Value</th>
    <th>Prefix</th>
  </tr>
  <tr>
    <td>0</td>
    <td>"http://"</td>
  </tr>
  <tr>
    <td>1</td>
    <td>"https://"</td>
  </tr>
  <tr>
    <td>255</td>
    <td>""</td>
  </tr>
</table>

The special value <code>255</code> indicates that the entire URL, including
scheme, is encoded in the <code>URL</code> field.

# Device Enumeration # {#enumeration}

<xmp class="idl">
  dictionary USBDeviceFilter {
    unsigned short vendorId;
    unsigned short productId;
    octet classCode;
    octet subclassCode;
    octet protocolCode;
    DOMString serialNumber;
  };

  dictionary USBDeviceRequestOptions {
    required sequence<USBDeviceFilter> filters;
  };

  [Exposed=(DedicatedWorker,SharedWorker,Window), SecureContext]
  interface USB : EventTarget {
    attribute EventHandler onconnect;
    attribute EventHandler ondisconnect;
    Promise<sequence<USBDevice>> getDevices();
    [Exposed=Window] Promise<USBDevice> requestDevice(USBDeviceRequestOptions options);
  };

  [Exposed=Window, SecureContext]
  partial interface Navigator {
    [SameObject] readonly attribute USB usb;
  };

  [Exposed=(DedicatedWorker,SharedWorker), SecureContext]
  partial interface WorkerNavigator {
    [SameObject] readonly attribute USB usb;
  };
</xmp>

<div class="example">
In this example, we retrieve some devices to include in a UI. When the page is
first loaded, it should check if it already has permission to access any
connected devices by calling {{USB/getDevices()}},

<pre highlight="js">
  document.addEventListener('DOMContentLoaded', async () => {
    let devices = await navigator.usb.getDevices();
    devices.forEach(device => {
      // Add |device| to the UI.
    });
  });
</pre>

After the page is loaded the user may <a>connect</a> or <a>disconnect</a> a
device from their system so script should also register for these events in
order to keep the interface up-to-date,

<pre highlight="js">
  navigator.usb.addEventListener('connect', event => {
    // Add |event.device| to the UI.
  });

  navigator.usb.addEventListener('disconnect', event => {
    // Remove |event.device| from the UI.
  });
</pre>

If this is the first time the user has visited the page then it won't have
permission to access any devices so the page must first call
{{USB/requestDevice()}} while the [=relevant global object=] has a
<a>transient activation</a>. In this case the page supports devices from vendor
<code>0xABCD</code> that carry the vendor-specific subclass <code>0x01</code>,

<pre highlight="js">
  let button = document.getElementById('request-device');
  button.addEventListener('click', async () => {
    let device;
    try {
      device = await navigator.usb.requestDevice({ filters: [{
          vendorId: 0xABCD,
          classCode: 0xFF, // vendor-specific
          protocolCode: 0x01
      }]});
    } catch (err) {
      // No device was selected.
    }

    if (device !== undefined) {
      // Add |device| to the UI.
    }
  });
</pre>
</div>

A USB device |device| <dfn data-lt="match a device filter">matches a device
filter</dfn> |filter| if the following steps return <code>match</code>:

  1. Let |deviceDesc| be |device|'s <a>device descriptor</a>.
  1. If <code>|filter|.{{USBDeviceFilter/vendorId}}</code> is present and
     <code>|deviceDesc|.idVendor</code> does not equal
     <code>|filter|.{{USBDeviceFilter/vendorId}}</code>, return
     <code>mismatch</code>.
  1. If <code>|filter|.{{USBDeviceFilter/productId}}</code> is present and
     <code>|deviceDesc|.idProduct</code> does not equal
     <code>|filter|.{{USBDeviceFilter/productId}}</code>, return
     <code>mismatch</code>.
  1. If <code>|filter|.{{USBDeviceFilter/serialNumber}}</code> is present then,
     let |serialNumber| be the <a>string descriptor</a> with index
     <code>|deviceDesc|.iSerialNumber</code>. If |device| returns an error when
     requesting |serialNumber| or |serialNumber| is not equal to
     <code>|filter|.{{USBDeviceFilter/serialNumber}}</code>, return
     <code>mismatch</code>.
  1. If <code>|filter|.{{USBDeviceFilter/classCode}}</code> is present and,
     for any of |device|'s interface's |interface|, |interface| <a>matches
     the interface filter</a> |filter|, return <code>match</code>.
  1. If <code>|filter|.{{USBDeviceFilter/classCode}}</code> is present and
     <code>|deviceDesc|.bDeviceClass</code> is not equal to
     <code>|filter|.{{USBDeviceFilter/classCode}}</code>, return
     <code>mismatch</code>.
  1. If <code>|filter|.{{USBDeviceFilter/subclassCode}}</code> is present and
     <code>|deviceDesc|.bDeviceSubClass</code> is not equal to
     <code>|filter|.{{USBDeviceFilter/subclassCode}}</code>, return
     <code>mismatch</code>.
  1. If <code>|filter|.{{USBDeviceFilter/protocolCode}}</code> is present and
     <code>|deviceDesc|.bDeviceProtocol</code> is not equal to
     <code>|filter|.{{USBDeviceFilter/protocolCode}}</code>, return
     <code>mismatch</code>.
  1. Return <code>match</code>.

Note: The steps above treat the <code>bDeviceClass</code>,
<code>bDeviceSubClass</code> and <code>bDeviceProtocol</code> fields of the
<a>device descriptor</a> as though they were part of an <a>interface
descriptor</a> which is also compared against the provided filter.

A USB interface |interface| <dfn data-lt="matches the interface filter">matches
an interface filter</dfn> |filter| if the following steps return
<code>match</code>:

  1. Let |desc| be |interface|'s <a>interface descriptor</a>.
  1. If <code>|filter|.{{USBDeviceFilter/classCode}}</code> is present and
     <code>|desc|.bInterfaceClass</code> is not equal to
     <code>|filter|.{{USBDeviceFilter/classCode}}</code>, return
     <code>mismatch</code>.
  1. If <code>|filter|.{{USBDeviceFilter/subclassCode}}</code> is present and
     <code>|desc|.bInterfaceSubClass</code> is not equal to
     <code>|filter|.{{USBDeviceFilter/subclassCode}}</code>, return
     <code>mismatch</code>.
  1. If <code>|filter|.{{USBDeviceFilter/protocolCode}}</code> is present and
     <code>|desc|.bInterfaceProtocol</code> is not equal to
     <code>|filter|.{{USBDeviceFilter/protocolCode}}</code>, return
     <code>mismatch</code>.
  1. Return <code>match</code>.

A {{USBDeviceFilter}} |filter|
<dfn data-lt="is not a valid filter">is valid</dfn> if the following steps
return <code>valid</code>:

  1. If <code>|filter|.{{USBDeviceFilter/productId}}</code> is present and
     <code>|filter|.{{USBDeviceFilter/vendorId}}</code> is not present,
     return <code>invalid</code>.
  1. If <code>|filter|.{{USBDeviceFilter/subclassCode}}</code> is present and
     <code>|filter|.{{USBDeviceFilter/classCode}}</code> is not present,
     return <code>invalid</code>.
  1. If <code>|filter|.{{USBDeviceFilter/protocolCode}}</code> is present and
     <code>|filter|.{{USBDeviceFilter/subclassCode}}</code> is not present,
     return <code>invalid</code>.
  1. Return <code>valid</code>.

The UA MUST be able to <dfn>enumerate all devices attached to the system</dfn>.
It is, however NOT required to perform this work each time an algorithm
requests an enumeration. The UA MAY cache the result of the first enumeration
it performs and then begin monitoring for device connection and disconnection
events, adding connected devices to its cached enumeration and removing
disconnected devices. This mode of operation is preferred as it reduces the
number of operating system calls made and amount of bus traffic generated by
the {{USB/getDevices()}} and {{USB/requestDevice()}} methods.

The {{USB/onconnect}} attribute is an Event handler IDL attribute for the
<a>connect</a> event type.

The {{USB/ondisconnect}} attribute is an Event handler IDL attribute for the
<a>disconnect</a> event type.

The {{USB/getDevices()}} method, when invoked, MUST return a new {{Promise}} and
run the following steps <a>in parallel</a>:

  1. <a>Enumerate all devices attached to the system</a>. Let this result be
     |enumerationResult|.
  2. Let |devices| be a new empty {{Array}}.
  3. For each |device| in |enumerationResult|:
     1. If this is the first call to this method, <a>check permissions for
        |device|</a>.
     2. Search for an element |allowedDevice| in
        <code>|storage|.{{USBPermissionStorage/allowedDevices}}</code> where
        |device| is in |allowedDevice|@{{[[devices]]}}. If no such element
        exists, continue to the next |device|.
     3. Add the {{USBDevice}} object representing |device| to |devices|.
  4. <a>Resolve</a> |promise| with |devices|.

The {{USB/requestDevice()}} method, when invoked, MUST run the following steps:

  1. <a>Request permission to use</a> the following descriptor,
     <pre highlight="js">
       {
         name: "usb"
         filters: <var>options</var>.<a idl for="USBDeviceRequestOptions">filters</a>
       }
     </pre>
     Let |permissionResult| be the resulting {{Promise}}.
  2. <a>Upon fulfillment</a> of |permissionResult| with |result| run the
     following steps:
       1. If <code>|result|.{{USBPermissionResult/devices}}</code> is empty,
          throw a {{NotFoundError}} and abort these steps.
       2. Return <code>|result|.{{USBPermissionResult/devices}}[0]</code>.

To <dfn>request the "usb" permission</dfn>, given a {{USBPermissionStorage}}
|storage|, a {{USBPermissionDescriptor}} |options| and a {{USBPermissionResult}}
|status|, the UA MUST return a new {{Promise}} |promise| and run the following
steps <a>in parallel</a>:

  1. For each |filter| in
     <code>|options|.{{USBPermissionDescriptor/filters}}</code> if |filter|
     <a>is not a valid filter</a> <a>reject</a> |promise| with a {{TypeError}}
     and abort these steps.
  2. Check that the algorithm was triggered while the [=relevant global object=]
     had a <a>transient activation</a>. Otherwise, <a>reject</a> |promise| with
     a {{SecurityError}} and abort these steps.
  3. Set <code>|status|.{{PermissionStatus/state}}</code> to `"ask"`.
  4. <a>Enumerate all devices attached to the system</a>. Let this result be
     |enumerationResult|.
  5. Remove devices from |enumerationResult| if they do not <a>match a device
     filter</a> in <code>|options|.{{USBPermissionDescriptor/filters}}</code>.
  6. Display a prompt to the user requesting they select a device from
     |enumerationResult|. The UA SHOULD show a human-readable name for each
     device.
  7. Wait for the user to have selected a |device| or cancelled the
     prompt.
  8. If the user cancels the prompt, set
     <code>|status|.{{USBPermissionResult/devices}}</code> to an empty
     {{FrozenArray}}, <a>resolve</a> |promise| with <code>undefined</code>,
     and abort these steps.
  9. <a>Add |device| to |storage|</a>.
  10. Let |deviceObj| be the {{USBDevice}} object representing |device|.
  11. Set <code>|status|.{{USBPermissionResult/devices}}</code> to a new
      {{FrozenArray}} containing |deviceObj| as its only element.
  12. <a>Resolve</a> |promise| with <code>undefined</code>.

To <dfn data-lt="add device to storage">add an allowed <a>USB device</a></dfn>
|device| to {{USBPermissionStorage}} |storage|, the UA MUST run the following
steps:

  1. Search for an element |allowedDevice| in
     <code>|storage|.{{USBPermissionStorage/allowedDevices}}</code> where
     |device| is in |allowedDevice|@{{[[devices]]}}. If one is found, abort
     these steps.
  2. Let |vendorId| and |productId| be |device|'s <a>vendor ID</a> and
     <a>product ID</a>.
  3. Let |serialNumber| be |device|'s <a>serial number</a> if it has one,
     otherwise <code>undefined</code>.
  6. Append <code>{ vendorId: |vendorId|, productId: |productId|, serialNumber: |serialNumber| }</code>,
     with a {{[[devices]]}} internal slot containing a single entry |device| to
     <code>|storage|.{{USBPermissionStorage/allowedDevices}}</code>.

To <dfn data-lt="check permissions for device">check permissions for a new
<a>USB device</a></dfn> |device|, given a {{USBPermissionStorage}} |storage|,
the UA MUST run the following steps:

  1. Let |vendorId| and |productId| be |device|'s <a>vendor ID</a> and
     <a>product ID</a>.
  2. Let |serialNumber| be |device|'s if it has one, otherwise
     <code>undefined</code>.
  3. Search for an element |allowedDevice| in
     <code>|storage|.{{USBPermissionStorage/allowedDevices}}</code> where:
       * <code>|allowedDevice|.{{AllowedUSBDevice/vendorId}}</code> equals
         |vendorId|.
       * <code>|allowedDevice|.{{AllowedUSBDevice/productId}}</code> equals
         |productId|.
       * <code>|allowedDevice|.{{AllowedUSBDevice/serialNumber}}</code> equals
         |serialNumber|.
  4. If no such element exists, return <code>null</code>.
  5. Add |device| to |allowedDevice|@{{[[devices]]}}.
  6. Return |allowedDevice|.

## Events ## {#events}

<xmp class="idl">
dictionary USBConnectionEventInit : EventInit {
    required USBDevice device;
};

[
  Exposed=(DedicatedWorker,SharedWorker,Window),
  SecureContext
]
interface USBConnectionEvent : Event {
  constructor(DOMString type, USBConnectionEventInit eventInitDict);
  [SameObject] readonly attribute USBDevice device;
};
</xmp>

When the UA detects a new <a>USB device</a> |device| connected to the host it
MUST perform the following steps for each script execution environment:

  1. Let |storage| be the {{USBPermissionStorage}} object in the current
     script execution environment.
  2. <a>Check permissions for |device|</a> with |storage| and let
     |allowedDevice| be the result.
  3. If |allowedDevice| is <code>null</code>, abort these steps.
  4. Let |deviceObj| be the {{USBDevice}} object representing |device|.
  5. Let |event| be a new {{USBConnectionEvent}}, with the <code>device</code>
     attribute set to |deviceObj|.
  6. Fire an event named <dfn>connect</dfn> on {{Navigator/usb}}, using |event|
     as the event object.

When the UA detects a <a>USB device</a> |device| has been disconnected from the
host it MUST perform the following steps for each script execution environment:

  1. Let |storage| be the {{USBPermissionStorage}} object in the current
     script execution environment.
  2. Search for an element |allowedDevice| in
     <code>|storage|.{{USBPermissionStorage/allowedDevices}}</code> where
     |device| is in |allowedDevice|@{{[[devices]]}}, if no such element exists,
     abort these steps.
  3. Remove |device| from |allowedDevice|@{{[[devices]]}}.
  4. If <code>|allowedDevice|.{{AllowedUSBDevice/serialNumber}}</code> is
     <code>undefined</code> and |allowedDevice|@{{[[devices]]}} is empty remove
     |allowedDevice| from
     <code>|storage|.{{USBPermissionStorage/allowedDevices}}</code>.
  5. Let |device| be the {{USBDevice}} object representing |device|.
  6. Let |event| be a new {{USBConnectionEvent}}, with the <code>device</code>
     attribute set to |device|.
  7. Fire an event named <dfn>disconnect</dfn> on {{Navigator/usb}}, using
     |event| as the event object.

# Device Usage # {#device-usage}

<xmp class="idl">
  [Exposed=(DedicatedWorker,SharedWorker,Window), SecureContext]
  interface USBDevice {
    readonly attribute octet usbVersionMajor;
    readonly attribute octet usbVersionMinor;
    readonly attribute octet usbVersionSubminor;
    readonly attribute octet deviceClass;
    readonly attribute octet deviceSubclass;
    readonly attribute octet deviceProtocol;
    readonly attribute unsigned short vendorId;
    readonly attribute unsigned short productId;
    readonly attribute octet deviceVersionMajor;
    readonly attribute octet deviceVersionMinor;
    readonly attribute octet deviceVersionSubminor;
    readonly attribute DOMString? manufacturerName;
    readonly attribute DOMString? productName;
    readonly attribute DOMString? serialNumber;
    readonly attribute USBConfiguration? configuration;
    readonly attribute FrozenArray<USBConfiguration> configurations;
    readonly attribute boolean opened;
    Promise<void> open();
    Promise<void> close();
    Promise<void> selectConfiguration(octet configurationValue);
    Promise<void> claimInterface(octet interfaceNumber);
    Promise<void> releaseInterface(octet interfaceNumber);
    Promise<void> selectAlternateInterface(octet interfaceNumber, octet alternateSetting);
    Promise<USBInTransferResult> controlTransferIn(USBControlTransferParameters setup, unsigned short length);
    Promise<USBOutTransferResult> controlTransferOut(USBControlTransferParameters setup, optional BufferSource data);
    Promise<void> clearHalt(USBDirection direction, octet endpointNumber);
    Promise<USBInTransferResult> transferIn(octet endpointNumber, unsigned long length);
    Promise<USBOutTransferResult> transferOut(octet endpointNumber, BufferSource data);
    Promise<USBIsochronousInTransferResult> isochronousTransferIn(octet endpointNumber, sequence<unsigned long> packetLengths);
    Promise<USBIsochronousOutTransferResult> isochronousTransferOut(octet endpointNumber, BufferSource data, sequence<unsigned long> packetLengths);
    Promise<void> reset();
  };
</xmp>

<div class="example">
In this example we imagine a data logging device supporting up to 8 16-bit data
channels. It has a single configuration (<code>bConfigurationValue 1</code>)
with a single interface (<code>bInterfaceNumber 1</code>) with a single
bulk endpoint (<code>bEndpointAddress 0x81</code> which means that it is
endpoint 1 and an IN endpoint). When data is sampled it is available on this
endpoint. The maximum packet size on this endpoint is 16 bytes to support all 8
channels being activated at the same time. To save bus bandwidth, however, any
combination of channels can be activated and deactivated. The packet will only
be the length necessary to transmit the data collected.

To get started we open the device, select the first configuration (it only has
one but the operating system may not have already done this during enumeration)
and claim the data logging interface,

<pre highlight="js">
  await device.<a idl for="USBDevice" data-lt="open()">open</a>();
  if (device.<a idl for="USBDevice">configuration</a> === null)
    await device.<a idl for="USBDevice" data-lt="selectConfiguration()">selectConfiguration</a>(1);
  await device.<a idl for="USBDevice" data-lt="claimInterface()">claimInterface</a>(1);
</pre>

For this particular application we care about reading from channels 1, 2 and 5
so we issue a <a>control transfer</a> to activate these channels,

<pre highlight="js">
  await device.<a idl for="USBDevice" data-lt="controlTransferOut()">controlTransferOut</a>({
      <a idl for="USBControlTransferParameters">requestType</a>: '<a idl for="USBRequestType">vendor</a>',
      <a idl for="USBControlTransferParameters">recipient</a>: '<a idl for="USBRecipient">interface</a>',
      <a idl for="USBControlTransferParameters">request</a>: 0x01,  // vendor-specific request: enable channels
      <a idl for="USBControlTransferParameters">value</a>: 0x0013,  // 0b00010011 (channels 1, 2 and 5)
      <a idl for="USBControlTransferParameters">index</a>: 0x0001   // Interface 1 is the recipient
  });
</pre>

The application may now start polling the device for data. As we only expect
data from 3 channels we request a 6 byte buffer. As long as we receive a
complete buffer the captured values (transmitted in big endian) are printed to
the console log. If the device has encountered an error and signals this by
stalling the endpoint then the error is cleared before continuing,

<pre highlight="js">
  while (true) {
    let result = await data.<a idl for="USBDevice" data-lt="transferIn()">transferIn</a>(1, 6);

    if (result.<a idl for="USBInTransferResult">data</a> && result.data.byteLength === 6) {
      console.log('Channel 1: ' + result.data.getUint16(0));
      console.log('Channel 2: ' + result.data.getUint16(2));
      console.log('Channel 5: ' + result.data.getUint16(4));
    }

    if (result.<a idl for="USBInTransferResult">status</a> === 'stall') {
      console.warn('Endpoint stalled. Clearing.');
      await device.<a idl for="USBDevice" data-lt="clearHalt()">clearHalt</a>(1);
    }
  }
</pre>
</div>

The {{USBDevice/usbVersionMajor}}, {{USBDevice/usbVersionMinor}} and
{{USBDevice/usbVersionSubminor}} attributes declare the USB protocol version
supported by the device. They SHALL correspond to the value of the
<code>bcdUSB</code> field of the <a>device descriptor</a> such that a value of
<code>0xJJMN</code> has major version <code>JJ</code>, minor version
<code>M</code> and subminor version <code>N</code>.

The {{USBDevice/deviceClass}}, {{USBDevice/deviceSubclass}} and
{{USBDevice/deviceProtocol}} attributes declare the communication interface
supported by the device. They MUST correspond respectively to the values of the
<code>bDeviceClass</code>, <code>bDeviceSubClass</code> and
<code>bDeviceProtocol</code> fields of the <a>device descriptor</a>.

The {{USBDevice/vendorId}} and {{USBDevice/productId}} MUST be equal to the
device's <a>vendor ID</a> and <a>product ID</a>.

The {{USBDevice/deviceVersionMajor}}, {{USBDevice/deviceVersionMinor}} and
{{USBDevice/deviceVersionSubminor}} attributes declare the device release
number as defined by the device manufacturer. It SHALL correspond to the value
of the <code>bcdDevice</code> field of the <a>device descriptor</a> such that a
value of <code>0xJJMN</code> has major version <code>JJ</code>, minor version
<code>M</code> and subminor version <code>N</code>.

The {{USBDevice/manufacturerName}}, {{USBDevice/productName}} and
{{USBDevice/serialNumber}} attributes SHOULD contain the values of the <a>string
descriptors</a> indexed by the <code>iManufacturer</code>, <code>iProduct</code>
and <code>iSerialNumber</code> fields of the <a>device descriptor</a> if each is
defined.

The {{USBDevice/configuration}} attribute contains the currently selected
configuration for the device and SHALL be one of the configurations listed in
{{USBDevice/configurations}}. It MAY be <code>null</code> if the device is in
an unconfigured state and MUST be updated by
{{USBDevice/selectConfiguration()}}.

The {{USBDevice/configurations}} attribute contains a list of configurations
supported by the device. These configurations SHALL be populated from the
configuration descriptors reported by the device and the number of elements in
this list SHALL match the value of the <code>bNumConfigurations</code> field of
the <a>device descriptor</a>.

The {{USBDevice/opened}} attribute SHALL be set to <code>true</code> when the
device is opened by the current execution context and SHALL be set to
<code>false</code> otherwise.

The {{USBDevice/open()}} method, when invoked, MUST return a new {{Promise}}
|promise| and run the following steps <a>in parallel</a>:

  1. Let |device| be the target {{USBDevice}} object.
  2. If |device| is no longer connected to the system, <a>reject</a> |promise|
     with a {{NotFoundError}} and abort these steps.
  3. If <code>|device|.{{USBDevice/opened}}</code> is <code>true</code>
     <a>resolve</a> |promise| and abort these steps.
  4. Perform the necessary platform-specific steps to begin a session with the
     device. If these fail for any reason <a>reject</a> |promise| with a
     {{NetworkError}} and abort these steps.
  5. Set <code>|device|.{{USBDevice/opened}}</code> to <code>true</code> and
     <a>resolve</a> |promise|.

The {{USBDevice/close()}} method, when invoked, MUST return a new {{Promise}}
|promise| and run the following steps <a>in parallel</a>:

  1. Let |device| be the target {{USBDevice}} object.
  2. If |device| is no longer connected to the system, <a>reject</a> |promise|
     with a {{NotFoundError}} and abort these steps.
  3. If <code>|device|.{{USBDevice/opened}}</code> is <code>false</code>
     <a>resolve</a> |promise| and abort these steps.
  4. Abort all other algorithms currently running against this device and
     <a>reject</a> their associated promises with an {{AbortError}}.
  5. Perform the necessary platform-specific steps to release any claimed
     interfaces as if {{USBDevice/releaseInterface(interfaceNumber)}} had been
     called for each claimed interface.
  6. Perform the necessary platform-specific steps to end the session with the
     device.
  7. Set <code>|device|.{{USBDevice/opened}}</code> to <code>false</code> and
     <a>resolve</a> |promise|.

When no [[!ECMAScript]] code can observe an instance of {{USBDevice}} |device|
anymore, the UA SHOULD run |device|.{{USBDevice/close()}}.

The {{USBDevice/selectConfiguration(configurationValue)}} method, when invoked,
MUST return a new {{Promise}} |promise| and run the following steps in
parallel:

  1. Let |device| be the target {{USBDevice}} object.
  2. If |device| is no longer connected to the system, <a>reject</a> |promise|
     with a {{NotFoundError}} and abort these steps.
  3. Let |configuration| be the device configuration with
     <code>bConfigurationValue</code> equal to |configurationValue|. If no such
     configuration exists, <a>reject</a> |promise| with a {{NotFoundError}} and
     abort these steps.
  4. If <code>|device|.{{USBDevice/opened}}</code> is not equal to
     <code>true</code> <a>reject</a> |promise| with an {{InvalidStateError}} and
     abort these steps.
  5. Abort all transfers currently scheduled on endpoints other than the
     <a>default control pipe</a> and <a>reject</a> their associated promises
     with a {{AbortError}}.
  6. Issue a <code>SET_CONFIGURATION</code> <a>control transfer</a> to the
     device to set |configurationValue| as its <a>active configuration</a>.
     If this step fails <a>reject</a> |promise| with a {{NetworkError}} and
     abort these steps.
  7. Set <code>|device|.{{USBDevice/configuration}}</code> to |configuration|
     and <a>resolve</a> |promise|.

The {{USBDevice/claimInterface(interfaceNumber)}} method, when invoked, MUST
return a new {{Promise}} |promise| and run the following steps <a>in
parallel</a>:

  1. If the device is no longer connected to the system, <a>reject</a> |promise|
     with a {{NotFoundError}} and abort these steps.
  1. Let |interface| be the interface in the <a>active configuration</a> with
     <code>bInterfaceNumber</code> equal to |interfaceNumber|. If no such
     interface exists, <a>reject</a> |promise| with a {{NotFoundError}} and
     abort these steps.
  1. If <code>|device|.{{USBDevice/opened}}</code> is not <code>true</code>,
     <a>reject</a> |promise| with an {{InvalidStateError}} and abort these
     steps.
  1. If <code>|interface|.{{USBInterface/claimed}}</code> is <code>true</code>,
     <a>resolve</a> |promise| and abort these steps.
  1. Perform the necessary platform-specific steps to request exclusive control
     over |interface| for the current execution context. If this fails,
     <a>reject</a> |promise| with a {{NetworkError}} and abort these steps.
  1. Set <code>|interface|.{{USBInterface/claimed}}</code> to <code>true</code>
     and <a>resolve</a> |promise|.

The {{USBDevice/releaseInterface(interfaceNumber)}} method, when invoked, MUST
return a new {{Promise}} |promise| and run the following steps <a>in
parallel</a>:

  1. Let |device| be the target {{USBDevice}} object.
  1. If |device| is no longer connected to the system, <a>reject</a> |promise|
     with a {{NotFoundError}} and abort these steps.
  1. Let |interface| be the interface in the <a>active configuration</a> with
     <code>bInterfaceNumber</code> equal to |interfaceNumber|. If no such
     interface exists, <a>reject</a> |promise| with a {{NotFoundError}} and
     abort these steps.
  1. If <code>|device|.{{USBDevice/opened}}</code> is not <code>true</code>,
     <a>reject</a> |promise| with an {{InvalidStateError}} and abort these
     steps.
  1. If <code>|interface|.{{USBInterface/claimed}}</code> is <code>false</code>,
     <a>resolve</a> |promise| and abort these steps.
  1. Perform the necessary platform-specific steps to reliquish exclusive
     control over |interface|.
  1. Set <code>|interface|.{{USBInterface/claimed}}</code> to <code>false</code>
     and <a>resolve</a> |promise|.

The {{USBDevice/selectAlternateInterface(interfaceNumber, alternateSetting)}}
method, when invoked, MUST return a new {{Promise}} |promise| and run the
following steps <a>in parallel</a>:

  1. Let |device| be the target {{USBDevice}} object.
  2. If |device| is no longer connected to the system, <a>reject</a> |promise|
     with a {{NotFoundError}} and abort these steps.
  3. Let |interface| be the interface in the <a>active configuration</a> with
     <code>bInterfaceNumber</code> equal to |interfaceNumber|. If no such
     interface exists, <a>reject</a> |promise| with a {{NotFoundError}} and
     abort these steps.
  4. If <code>|device|.{{USBDevice/opened}}</code> or
     <code>|interface|.{{USBInterface/claimed}}</code> is not <code>true</code>,
     <a>reject</a> |promise| with an {{InvalidStateError}} and abort these
     steps.
  5. Abort all transfers currently scheduled on endpoints associated with the
     previously selected alternate setting of |interface| and <a>reject</a>
     their associated promises with a {{AbortError}}.
  6. Issue a <code>SET_INTERFACE</code> <a>control transfer</a> to the device
     to set |alternateSetting| as the current configuration of |interface|. If
     this step fails <a>reject</a> |promise| with a {{NetworkError}} and abort
     these steps.
  7. <a>Resolve</a> |promise|.

The {{USBDevice/controlTransferIn(setup, length)}} method, when invoked, MUST
return a new {{Promise}} |promise| and run the following steps in
parallel:

  1. Let |device| be the target {{USBDevice}} object.
  1. If |device| is no longer connected to the system, <a>reject</a> |promise|
     with a {{NotFoundError}} and abort these steps.
  1. If <code>|device|.{{USBDevice/opened}}</code> is not equal to
     <code>true</code> <a>reject</a> |promise| with an {{InvalidStateError}}
     and abort these steps.
  1. <a>Check the validity of the control transfer parameters</a> and abort
     these steps if |promise| is rejected.
  1. If |length| is greater than 0, let |buffer| be a host buffer with space
     for |length| bytes.
  1. Issue a <a>control transfer</a> to |device| with the setup packet parameters
     provided in |setup|, the data transfer direction in
     <code>bmRequestType</code> set to "device to host" and <code>wLength</code>
     set to |length|. If defined also provide |buffer| as the destination to
     write data received in response to this transfer.
  1. Let |bytesTransferred| be the number of bytes written to |buffer|.
  1. Let |result| be a new {{USBInTransferResult}}.
  1. If data was received from |device| create a new {{ArrayBuffer}} containing
     the first |bytesTransferred| bytes of |buffer| and set
     <code>|result|.{{USBInTransferResult/data}}</code> to a new {{DataView}}
     constructed over it.
  1. If |device| responded by stalling the
     <a>default control pipe</a> set
     <code>|result|.{{USBInTransferResult/status}}</code> to {{"stall"}}.
  2. If |device| responded with more than |length| bytes of data set
     <code>|result|.{{USBInTransferResult/status}}</code> to {{"babble"}} and
     otherwise set it to {{"ok"}}.
  3. If the transfer fails for any other reason <a>reject</a> |promise| with a
     {{NetworkError}} and abort these steps.
  4. <a>Resolve</a> |promise| with |result|.

The {{USBDevice/controlTransferOut(setup, data)}} method, when invoked, must
return a new {{Promise}} |promise| and run the following steps <a>in
parallel</a>:

  1. If the device is no longer connected to the system, <a>reject</a> |promise|
     with a {{NotFoundError}} and abort these steps.
  1. If <code>|device|.{{USBDevice/opened}}</code> is not equal to
     <code>true</code> <a>reject</a> |promise| with an {{InvalidStateError}} and
     abort these
     steps.
  1. <a>Check the validity of the control transfer parameters</a> and abort
     these steps if |promise| is rejected.
  1. Issue a <a>control transfer</a> with the <a>setup packet</a> populated by
     |setup| and the data transfer direction in <code>bmRequestType</code> set
     to "host to device" and <code>wLength</code> set to
     <code>|data|.length</code>. Transmit |data| in the <a>data stage</a> of
     the transfer.
  1. Let |result| be a new {{USBOutTransferResult}}.
  1. If the device responds by stalling the
     <a>default control pipe</a> set
     <code>|result|.{{USBOutTransferResult/status}}</code> to {{"stall"}}.
  1. If the device acknowledges the transfer set
     <code>|result|.{{USBOutTransferResult/status}}</code> to {{"ok"}} and
     <code>|result|.{{USBOutTransferResult/bytesWritten}}</code> to
     <code>|data|.length</code>.
  1. If the transfer fails for any other reason <a>reject</a> |promise| with a
     {{NetworkError}} and abort these steps.
  1. <a>Resolve</a> |promise| with |result|.

The {{USBDevice/clearHalt(direction, endpointNumber)}} method, when invoked,
MUST return a new {{Promise}} |promise| and run the following steps <a>in
parallel</a>:

  1. If the device is no longer connected to the system, <a>reject</a> |promise|
     with a {{NotFoundError}} and abort these steps.
  2. Let |endpoint| be the endpoint in the <a>active configuration</a> with
     <code>bEndpointAddress</code> corresponding to |direction| and
     |endpointNumber|. If no such endpoint exists <a>reject</a> |promise| and
     abort these steps.
  3. If <code>|device|.{{USBDevice/opened}}</code> or
     <code>|interface|.{{USBInterface/claimed}}</code> is not <code>true</code>,
     <a>reject</a> |promise| with an {{InvalidStateError}} and abort these
     steps.
  4. Issue a <code>ClearFeature(ENDPOINT_HALT)</code> <a>control transfer</a> to
     the device to clear the halt condition on |endpoint|.
  5. On failure <a>reject</a> |promise| with a {{NetworkError}}, otherwise
     <a>resolve</a> |promise|.

The {{USBDevice/transferIn(endpointNumber, length)}} method, when invoked, MUST
return a new {{Promise}} |promise| and run the following steps <a>in
parallel</a>:

  1. Let |device| be the target {{USBDevice}} object.
  2. If |device| is no longer connected to the system, <a>reject</a> |promise|
     with a {{NotFoundError}} and abort these steps.
  3. Let |endpoint| be the IN endpoint in the <a>active configuration</a> with
     <code>bEndpointAddress</code> corresponding to |endpointNumber|. If there
     is no such endpoint <a>reject</a> |promise| with a {{NotFoundError}} and
     abort these steps.
  4. If |endpoint| is not a bulk or interrupt endpoint <a>reject</a> |promise|
     with an {{InvalidAccessError}} and abort these steps.
  5. If <code>|device|.{{USBDevice/opened}}</code> or
     <code>|interface|.{{USBInterface/claimed}}</code> is not <code>true</code>,
     <a>reject</a> |promise| with an {{InvalidStateError}} and abort these
     steps.
  6. Let |buffer| be a host buffer with space for |length| bytes.
  7. As appropriate for |endpoint| enqueue a <a lt="bulk transfer">bulk</a> or
     <a lt="interrupt transfer">interrupt</a> <a>IN transfer</a> on |endpoint|
     to receive |length| bytes of data from the device into |buffer|.
  8. Let |bytesTransferred| be the number of bytes written to |buffer|.
  9. Let |result| be a new {{USBInTransferResult}}.
  10. If data was received from |device| create a new {{ArrayBuffer}} containing
     the first |bytesTransferred| bytes of |buffer| and set
     <code>|result|.{{USBInTransferResult/data}}</code> to a new {{DataView}}
     constructed over it.
  11. If |device| responded with more than |length| bytes of data set
     <code>|result|.{{USBInTransferResult/status}}</code> to {{"babble"}}.
  12. If the transfer ended because |endpoint| is halted set
     <code>|result|.{{USBInTransferResult/status}}</code> to {{"stall"}}.
  13. If |device| acknowledged the complete transfer set
     <code>|result|.{{USBInTransferResult/status}}</code> to {{"ok"}}.
  14. If the transfer failed for any other reason <a>reject</a> |promise| with a
     {{NetworkError}} and abort these steps.
  15. <a>Resolve</a> |promise| with |result|.

The {{USBDevice/transferOut(endpointNumber, data)}} method, when invoked, MUST
return a new {{Promise}} |promise| and run the following steps in
parallel:

  1. If the device is no longer connected to the system, <a>reject</a> |promise|
     with a {{NotFoundError}} and abort these steps.
  2. Let |endpoint| be the OUT endpoint in the <a>active configuration</a> with
     <code>bEndpointAddress</code> corresponding to |endpointNumber|. If there
     is no such endpoint <a>reject</a> |promise| with a {{NotFoundError}} and
     abort these steps.
  3. If |endpoint| is not a bulk or interrupt endpoint <a>reject</a> |promise|
     with an {{InvalidAccessError}} and abort these steps.
  4. If <code>|device|.{{USBDevice/opened}}</code> or
     <code>|interface|.{{USBInterface/claimed}}</code> is not <code>true</code>,
     <a>reject</a> |promise| with an {{InvalidStateError}} and abort these
     steps.
  5. As appropriate for |endpoint| enqueue a <a lt="bulk transfer">bulk</a> or
     <a lt="interrupt transfer">interrupt</a> <a>OUT transfer</a> on |endpoint|
     to transmit |data| to the device.
  6. Let |result| be a new {{USBOutTransferResult}}.
  7. Set <code>|result|.{{USBOutTransferResult/bytesWritten}}</code> to the
     amount of data successfully sent to the device.
  8. If the endpoint is stalled set
     <code>|result|.{{USBOutTransferResult/status}}</code> to {{"stall"}}.
  9. If the device acknowledges the complete transfer set
     <code>|result|.{{USBOutTransferResult/status}}</code> to {{"ok"}}.
  10. If the transfer fails for any other reason <a>reject</a> |promise| with a
      {{NetworkError}} and abort these steps.
  11. <a>Resolve</a> |promise| with |result|.

The {{USBDevice/isochronousTransferIn(endpointNumber, packetLengths)}} method,
when invoked, MUST return a new {{Promise}} |promise| and run the following
steps <a>in parallel</a>:

  1. If the device is no longer connected to the system, <a>reject</a> |promise|
     with a {{NotFoundError}} and abort these steps.
  2. Let |endpoint| be the IN endpoint in the <a>active configuration</a> with
     <code>bEndpointAddress</code> corresponding to |endpointNumber|. If there
     is no such endpoint <a>reject</a> |promise| with a {{NotFoundError}} and
     abort these steps.
  3. If |endpoint| is not an isochronous endpoint <a>reject</a> |promise| with
     an {{InvalidAccessError}} and abort these steps.
  4. If <code>|device|.{{USBDevice/opened}}</code> or
     <code>|interface|.{{USBInterface/claimed}}</code> is not <code>true</code>,
     <a>reject</a> |promise| with an {{InvalidStateError}} and abort these
     steps.
  5. Let |length| be the sum of the elements of |packetLengths|.
  6. Let |buffer| be a new {{ArrayBuffer}} of |length| bytes.
  7. Let |result| be a new {{USBIsochronousInTransferResult}} and set
     <code>|result|.{{USBIsochronousInTransferResult/data}}</code> to a new
     {{DataView}} constructed over |buffer|.
  8. Enqueue an <a lt="isochronous transfers">isochronous IN transfer</a> on
     |endpoint| that will write up to |length| bytes of data from the device
     into |buffer|.
  9. For each packet |i| from <code>0</code> to <code>|packetLengths|.length -
     1</code>:

       1. Let |packet| be a new {{USBIsochronousInTransferPacket}} and set
          <code>|result|.{{USBIsochronousInTransferResult/packets}}[i]</code>
          to |packet|.
       2. Let |view| be a new {{DataView}} over the portion of |buffer|
          containing the data received from the device for this packet and set
          <code>|packet|.{{USBIsochronousInTransferPacket/data}}</code> to
          |view|.
       3. If the device responds with more than <code>|packetLengths|[i]</code>
          bytes of data set
          <code>|packet|.{{USBIsochronousInTransferPacket/status}}</code> to
          {{"babble"}}.
       4. If the transfer ends because |endpoint| is stalled set
          <code>|packet|.{{USBIsochronousInTransferPacket/status}}</code> to
          {{"stall"}}.
       5. If the device acknowledges the complete transfer set
          <code>|packet|.{{USBIsochronousInTransferPacket/status}}</code> to
          {{"ok"}}.
       6. If the transfer fails for any other reason <a>reject</a> |promise|
          with a {{NetworkError}} and abort these steps.
  10. <a>Resolve</a> |promise| with |result|.

The {{USBDevice/isochronousTransferOut(endpointNumber, data, packetLengths)}}
method, when invoked, MUST return a new {{Promise}} |promise| and run the
following steps <a>in parallel</a>:

  1. If the device is no longer connected to the system, <a>reject</a> |promise|
     with a {{NotFoundError}} and abort these steps.
  2. Let |endpoint| be the OUT endpoint in the <a>active configuration</a> with
     <code>bEndpointAddress</code> corresponding to |endpointNumber|. If there
     is no such endpoint <a>reject</a> |promise| with a {{NotFoundError}} and
     abort these steps.
  3. If |endpoint| is not an isochronous endpoint <a>reject</a> |promise| with
     an {{InvalidAccessError}} and abort these steps.
  4. If <code>|device|.{{USBDevice/opened}}</code> or
     <code>|interface|.{{USBInterface/claimed}}</code> is not <code>true</code>,
     <a>reject</a> |promise| with an {{InvalidStateError}} and abort these
     steps.
  5. Let |length| be the sum of the elements of |packetLengths|.
  6. Let |result| be a new {{USBIsochronousOutTransferResult}}.
  7. Enqueue an <a lt="isochronous transfers">isochronous OUT transfer</a> on
     |endpoint| that will write |buffer| to the device, divided into
     <code>|packetLength|.length</code> packets of
     <code>|packetLength|[i]</code> bytes (for packets |i| from <code>0</code>
     to <code>|packetLengths|.length - 1</code>).
  8. For each packet |i| from <code>0</code> to <code>|packetLengths|.length -
     1</code> the host attempts to send to the device:

       1. Let |packet| be a new {{USBIsochronousOutTransferPacket}} and set
          <code>|result|.{{USBIsochronousOutTransferResult/packets}}[i]</code>
          to |packet|.
       2. Let
          <code>|packet|.{{USBIsochronousOutTransferPacket/bytesWritten}}</code>
          be the amount of data successfully sent to the device as part of this
          packet.
       3. If the transfer ends because |endpoint| is stalled set
          <code>|packet|.{{USBIsochronousOutTransferPacket/status}}</code> to
          {{"stall"}}.
       4. If the device acknowledges the complete transfer set
          <code>|packet|.{{USBIsochronousOutTransferPacket/status}}</code> to
          {{"ok"}}.
       5. If the transfer fails for any other reason <a>reject</a> |promise|
          with a {{NetworkError}} and abort these steps.
  9. <a>Resolve</a> |promise| with |result|.

The {{USBDevice/reset()}} method, when invoked, MUST return a new {{Promise}}
|promise| and run the following steps <a>in parallel</a>:

  1. Let |device| be the target {{USBDevice}} object.
  2. If |device| is no longer connected to the system, <a>reject</a> |promise|
     with a {{NotFoundError}} and abort these steps.
  3. If <code>|device|.{{USBDevice/opened}}</code> is not equal to
     <code>true</code> <a>reject</a> |promise| with an {{InvalidStateError}} and
     abort these steps.
  4. Abort all operations on the device and <a>reject</a> their associated
     promises with an {{AbortError}}.
  5. Perform the necessary platform-specific operation to soft reset the device.
  6. On failure <a>reject</a> |promise| with a {{NetworkError}}, otherwise
     <a>resolve</a> |promise|.

Issue(36):
What configuration is the device in after it resets?

## Transfers ## {#transfers}

<xmp class="idl">
  enum USBRequestType {
    "standard",
    "class",
    "vendor"
  };

  enum USBRecipient {
    "device",
    "interface",
    "endpoint",
    "other"
  };

  enum USBTransferStatus {
    "ok",
    "stall",
    "babble"
  };

  dictionary USBControlTransferParameters {
    required USBRequestType requestType;
    required USBRecipient recipient;
    required octet request;
    required unsigned short value;
    required unsigned short index;
  };

  [
    Exposed=(DedicatedWorker,SharedWorker,Window),
    SecureContext
  ]
  interface USBInTransferResult {
    constructor(USBTransferStatus status, optional DataView? data);
    readonly attribute DataView? data;
    readonly attribute USBTransferStatus status;
  };

  [
    Exposed=(DedicatedWorker,SharedWorker,Window),
    SecureContext
  ]
  interface USBOutTransferResult {
    constructor(USBTransferStatus status, optional unsigned long bytesWritten = 0);
    readonly attribute unsigned long bytesWritten;
    readonly attribute USBTransferStatus status;
  };

  [
    Exposed=(DedicatedWorker,SharedWorker,Window),
    SecureContext
  ]
  interface USBIsochronousInTransferPacket {
    constructor(USBTransferStatus status, optional DataView? data);
    readonly attribute DataView? data;
    readonly attribute USBTransferStatus status;
  };

  [
    Exposed=(DedicatedWorker,SharedWorker,Window),
    SecureContext
  ]
  interface USBIsochronousInTransferResult {
    constructor(sequence<USBIsochronousInTransferPacket> packets, optional DataView? data);
    readonly attribute DataView? data;
    readonly attribute FrozenArray<USBIsochronousInTransferPacket> packets;
  };

  [
    Exposed=(DedicatedWorker,SharedWorker,Window),
    SecureContext
  ]
  interface USBIsochronousOutTransferPacket {
    constructor(USBTransferStatus status, optional unsigned long bytesWritten = 0);
    readonly attribute unsigned long bytesWritten;
    readonly attribute USBTransferStatus status;
  };

  [
    Exposed=(DedicatedWorker,SharedWorker,Window),
    SecureContext
  ]
  interface USBIsochronousOutTransferResult {
    constructor(sequence<USBIsochronousOutTransferPacket> packets);
    readonly attribute FrozenArray<USBIsochronousOutTransferPacket> packets;
  };
</xmp>

A <dfn>control transfer</dfn> is a special class of USB traffic most commonly
used for configuring a device. It consists of three stages:
<a lt="setup stage">setup</a>, <a lt="data stage">data</a> and
<a lt="status stage">status</a>. In the <dfn>setup stage</dfn> a
<dfn>setup packet</dfn> is transmitted to the device containing request
parameters including the transfer direction and size of the data to follow. In
the <dfn>data stage</dfn> that data is either sent to or received from the
device. In the <dfn>status stage</dfn> successful handling of the request is
acknowledged or a failure is signaled.

All USB devices MUST have a <a>default control pipe</a> which is
|endpointNumber| <code>0</code>.

The {{USBControlTransferParameters/requestType}} attribute populates part of
the <code>bmRequestType</code> field of the <a>setup packet</a> to indicate
whether this request is part of the USB standard, a particular USB device class
specification or a vendor-specific protocol.

The {{USBControlTransferParameters/recipient}} attribute populates part of the
<code>bmRequestType</code> field of the <a>setup packet</a> to indicate whether
the <a>control transfer</a> is addressed to the entire device, or a specific
interface or endpoint.

The {{USBControlTransferParameters/request}} attribute populates the
<code>bRequest</code> field of the <a>setup packet</a>. Valid requests are
defined by the USB standard, USB device class specifications or the device
vendor.

The {{USBControlTransferParameters/value}} and
{{USBControlTransferParameters/index}} attributes populate the
<code>wValue</code> and <code>wIndex</code> fields of the <a>setup packet</a>
respectively. The meaning of these fields depends on the request being made.

To <dfn>check the validity of the control transfer parameters</dfn>
perform the following steps:

  1. Let |setup| be the {{USBControlTransferParameters}} created for the
     transfer.
  2. Let |promise| be the promise created for the transfer.
  3. Let |configuration| be the <a>active configuration</a>. If the device is
     not configured abort these steps.
  4. If <code>|setup|.{{USBControlTransferParameters/recipient}}</code> is
     {{"interface"}}, perform the following steps:
       1. Let |interfaceNumber| be the lower 8 bits of
          <code>|setup|.{{USBControlTransferParameters/index}}</code>.
       2. Let |interface| be the interface in the | configuration| with
          <code>bInterfaceNumber</code> equal to |interfaceNumber|. If no such
          interface exists, <a>reject</a> |promise| with a {{NotFoundError}} and
          abort these steps.
       3. If <code>|interface|.{{USBInterface/claimed}}</code> is not equal to
          <code>true</code>, <a>reject</a> |promise| with an
          {{InvalidStateError}} and abort these steps.
  5. If <code>|setup|.{{USBControlTransferParameters/recipient}}</code> is
     {{"endpoint"}}, run the following steps:
       1. Let |endpointNumber| be defined as the lower 4 bits of
          <code>|setup|.{{USBControlTransferParameters/index}}</code>.
       2. Let |direction| be defined as {{"in"}} if the 8th bit of
          <code>|setup|.{{USBControlTransferParameters/index}}</code> is
          <code>1</code> and {{"out"}} otherwise.
       3. Let |endpoint| be the endpoint in the <a>active configuration</a> with
          <code>bEndpointAddress</code> corresponding to |direction| and
          |endpointNumber|. If no such endpoint exists, <a>reject</a> |promise|
          with a {{NotFoundError}} and abort these steps.
       4. Let |interface| be the interface in which |endpoint| is defined. If
          <code>|interface|.{{USBInterface/claimed}}</code> is not equal to
          <code>true</code>, <a>reject</a> |promise| with an
          {{InvalidStateError}}.

## Configurations ## {#configurations}

<xmp class="idl">
  [
    Exposed=(DedicatedWorker,SharedWorker,Window),
    SecureContext
  ]
  interface USBConfiguration {
    constructor(USBDevice device, octet configurationValue);
    readonly attribute octet configurationValue;
    readonly attribute DOMString? configurationName;
    readonly attribute FrozenArray<USBInterface> interfaces;
  };
</xmp>

Each device configuration SHALL have a unique
{{USBConfiguration/configurationValue}} that matches the
<code>bConfigurationValue</code> fields of the <a>configuration descriptor</a>
that defines it.

The {{USBConfiguration/configurationName}} attribute SHOULD contain the value
of the <a>string descriptor</a> referenced by the <code>iConfiguration</code>
field of the <a>configuration descriptor</a>, if defined.

The {{USBConfiguration/interfaces}} attribute SHALL contain a list of
interfaces exposed by this device configuration. These interfaces SHALL by
populated by collecting the <a>interface descriptors</a> contained within this
<a>configuration descriptor</a> and organizing them by
<code>bInterfaceNumber</code>.

Issue(46):
Include some non-normative information about device configurations.

## Interfaces ## {#interfaces}

<xmp class="idl">
  [
    Exposed=(DedicatedWorker,SharedWorker,Window),
    SecureContext
  ]
  interface USBInterface {
    constructor(USBConfiguration configuration, octet interfaceNumber);
    readonly attribute octet interfaceNumber;
    readonly attribute USBAlternateInterface alternate;
    readonly attribute FrozenArray<USBAlternateInterface> alternates;
    readonly attribute boolean claimed;
  };

  [
    Exposed=(DedicatedWorker,SharedWorker,Window),
    SecureContext
  ]
  interface USBAlternateInterface {
    constructor(USBInterface deviceInterface, octet alternateSetting);
    readonly attribute octet alternateSetting;
    readonly attribute octet interfaceClass;
    readonly attribute octet interfaceSubclass;
    readonly attribute octet interfaceProtocol;
    readonly attribute DOMString? interfaceName;
    readonly attribute FrozenArray<USBEndpoint> endpoints;
  };
</xmp>

Each interface provides a collection of {{USBInterface/alternates}} identified
by a single <code>bInterfaceNumber</code> field found in their <a>interface
descriptors</a>. The {{USBInterface/interfaceNumber}} attribute MUST match this
field.

The {{USBInterface/alternate}} attribute SHALL be set to the
{{USBAlternateInterface}} that is currently selected for this interface, which
by default SHALL be the one with <code>bAlternateSetting</code> equal to
<code>0</code>.

The {{USBInterface/alternates}} attribute SHALL contain a list of all alternate
interface configurations available for this interface.

The {{USBInterface/claimed}} attribute SHALL be set to <code>true</code> when
the interface is claimed by the current execution context and SHALL be set to
<code>false</code> otherwise.

Each alternative interface configuration SHALL have a unique
{{USBAlternateInterface/alternateSetting}} within a given interface that
matches the <code>bAlternateSetting</code> field of the <a>interface
descriptor</a> that defines it.

The {{USBAlternateInterface/interfaceClass}},
{{USBAlternateInterface/interfaceSubclass}} and
{{USBAlternateInterface/interfaceProtocol}} attributes declare the
communication interface supported by the interface. They MUST correspond
respectively to the values of the <code>bInterfaceClass</code>,
<code>bInterfaceSubClass</code> and <code>bInterfaceProtocol</code> fields of
the <a>interface descriptor</a>.

The {{USBAlternateInterface/interfaceName}} attribute SHOULD contain the value
of the <a>string descriptor</a> indexed by the <code>iInterface</code> field of
the <a>interface descriptor</a>, if defined.

The {{USBAlternateInterface/endpoints}} attribute SHALL contain a list of
endpoints exposed by this interface. These endpoints SHALL by populated from
the <a>endpoint descriptors</a> contained within this
<a>interface descriptor</a> and the number of elements in this sequence SHALL
match the value of the <code>bNumEndpoints</code> field of the
<a>interface descriptor</a>.

A device's <dfn>active configuration</dfn> is the combination of the
{{USBConfiguration}} selected by calling
{{USBDevice/selectConfiguration(configurationValue)}} and the set of
{{USBAlternateInterface}}s selected by calling
{{USBDevice/selectAlternateInterface(interfaceNumber, alternateSetting)}}.  A
device MAY, by default, be left in an unconfigured state, referred to as
configuration <code>0</code> or may automatically be set to whatever
configuration has <code>bConfigurationValue</code> equal to <code>1</code>.
When a configuration is set all interfaces within that configuration
automatically have the {{USBAlternateInterface}} with
<code>bAlternateSetting</code> equal to <code>0</code> selected by default. It
is therefore unnecessary to call
{{USBDevice/selectAlternateInterface(interfaceNumber, alternateSetting)}} with
|alternateSetting| equal to <code>0</code> for each interface when opening a
device.

## Endpoints ## {#endpoints}

<xmp class="idl">
  enum USBDirection {
    "in",
    "out"
  };

  enum USBEndpointType {
    "bulk",
    "interrupt",
    "isochronous"
  };

  [
    Exposed=(DedicatedWorker,SharedWorker,Window),
    SecureContext
  ]
  interface USBEndpoint {
    constructor(USBAlternateInterface alternate, octet endpointNumber, USBDirection direction);
    readonly attribute octet endpointNumber;
    readonly attribute USBDirection direction;
    readonly attribute USBEndpointType type;
    readonly attribute unsigned long packetSize;
  };
</xmp>

Each endpoint within a particular device configuration SHALL have a unique
combination of {{USBEndpoint/endpointNumber}} and {{USBEndpoint/direction}}.
The {{USBEndpoint/endpointNumber}} MUST equal the 4 least significant bits of
the <code>bEndpointAddress</code> field of the <a>endpoint descriptor</a>
defining the endpoint.

The {{USBEndpoint/direction}} attribute declares the transfer direction
supported by this endpoint and is equal to {{"in"}} if the most
significant bit of the <code>bEndpointAddress</code> is set and
{{"out"}} otherwise. An endpoint may either carry data <code>IN</code>
from the device to host or <code>OUT</code> from host to device.

The {{USBEndpoint/type}} attribute declares the type of data transfer supported
by this endpoint.

The {{USBEndpoint/packetSize}} attribute declares the packet size employed by
this endpoint and MUST be equal to the value of the <code>wMaxPacketSize</code>
of the <a>endpoint descriptor</a> defining it. In a High-Speed, High-Bandwidth
endpoint this value will include the multiplication factor provided by issuing
multiple transactions per microframe. In a SuperSpeed device this value will
include the multiplication factor provided by the <code>bMaxBurst</code> field
of the SuperSpeed Endpoint Companion descriptor.

# Integrations # {#integrations}

## Feature Policy ## {#feature-policy}

This specification defines a <a>feature</a> that controls whether the
{{Navigator/usb}} attribute is exposed on the {{Navigator}} object.

The <a>feature name</a> for this feature is <code>"usb"</code>.

The <a>default allowlist</a> for this feature is <code>["self"]</code>.

## Permission API ## {#permission-api}

The [[permissions]] API provides a uniform way for websites to request
permissions from users and query which permissions they have.

The <dfn enum-value for="PermissionName">"usb"</dfn> <a>powerful feature</a> is
defined as follows:

<dl>
  <dt><a>permission descriptor type</a></dt>
  <dd>
    <xmp class="idl">
      dictionary USBPermissionDescriptor : PermissionDescriptor {
        sequence<USBDeviceFilter> filters;
      };
    </xmp>
  </dd>
  <dt><a>extra permission data type</a></dt>
  <dd>
    {{USBPermissionStorage}}, defined as:
    <xmp class="idl">
      dictionary AllowedUSBDevice {
        required octet vendorId;
        required octet productId;
        DOMString serialNumber;
      };

      dictionary USBPermissionStorage {
        sequence<AllowedUSBDevice> allowedDevices = [];
      };
    </xmp>

    {{AllowedUSBDevice}} instances have an internal slot
    <dfn attribute for="AllowedUSBDevice">\[[devices]]</dfn> that holds an
    array of <a>USB devices</a>.
  </dd>
  <dt><a>permission result type</a></dt>
  <dd>
    <xmp class="idl">
      [Exposed=(DedicatedWorker,SharedWorker,Window)]
      interface USBPermissionResult : PermissionStatus {
        attribute FrozenArray<USBDevice> devices;
      };
    </xmp>
  </dd>
  <dt><a>permission query algorithm</a></dt>
  <dd>
    To <strong><em>query the "usb" permission</em></strong> with a
    {{USBPermissionDescriptor}} |desc|, a {{USBPermissionStorage}} |storage|,
    and a {{USBPermissionResult}} |status|, the UA must:

      1. If <code>|desc|.{{USBPermissionDescriptor/filters}}</code> is set then,
         for each |filter| in
         <code>|desc|.{{USBPermissionDescriptor/filters}}</code> if |filter|
         <a>is not a valid filter</a> then raise a {{TypeError}} and abort these
         steps.
      2. Set <code>|status|.{{PermissionStatus/state}}</code> to
         {{"prompt"}}.
      3. Let |matchingDevices| be a new {{Array}}.
      4. For each |allowedDevice| in
         <code>|storage|.{{USBPermissionStorage/allowedDevices}}</code> and
         for each |device| in <code>|allowedDevice|@{{[[devices]]}}</code>, run
         the following substeps:

           1. If <code>|desc|.{{USBPermissionDescriptor/filters}}</code> is set
              and |device| does not <a>match a device filter</a> in
              <code>|desc|.{{USBPermissionDescriptor/filters}}</code>, continue
              to the next |device|.
           2. Get the {{USBDevice}} representing |device| and add it to
              |matchingDevices|.

      5. Set <code>|status|.{{USBPermissionResult/devices}}</code> to a new
         {{FrozenArray}} whose contents are |matchingDevices|.
  </dd>
  <dt><a>permission request algorithm</a></dt>
  <dd><a>Request the "usb" permission</a>.</dd>
</dl>

# Terminology # {#terminology}

This specification uses several terms taken from [[!USB31]]. While
reference is made to version 3.1 of the Universal Serial Bus many of
these concepts exist in previous versions as well. Significant
differences between USB versions that have bearing on this specification
will be called out explicitly.

<dfn>Descriptors</dfn> are binary data structures that can be read from
a device and describe its properties and function:

  * The <dfn>device descriptor</dfn> contains information applicable to
    the entire devices and is described in section 9.6.1 of [[!USB31]].
  * A <dfn>configuration descriptor</dfn> describes a particular set of
    device interfaces and endpoints that can be selected by the host.
    Its fields are described in section 9.6.3 of [[!USB31]].
  * An <dfn>interface descriptor</dfn> describes the interface of a particular
    functional component of a device including its protocol and communication
    endpoints. Its fields are described in section 9.6.5 of [[!USB31]].
  * An <strong><em>interface association descriptor</em></strong>
    creates an association between multiple interfaces that are part of a single
    functional unit of a device. Its fields are described in section
    9.6.4 of [[!USB31]].
  * An <dfn>endpoint descriptor</dfn> describes a channel through which
    data is either sent to or received from the device. Its fields are
    described in section 9.6.6 of [[!USB31]].
  * A <dfn>string descriptor</dfn> contains a single UTF16-LE string and is
    referenced by index by other descriptors. Its fields are described in
    section 9.6.9 of [[!USB31]].

The <dfn>Binary Object Store</dfn>
(<abbr title="Binary Object Store">BOS</abbr>) is an additional set of
descriptors that are more free-form than the standard device
descriptors. Of note is the <dfn>Platform Descriptor</dfn> type which
allows third parties (such as this specification) to declare their own
types of descriptors. Each of these is identified by a UUID. The Binary
Object Store is described in section 9.6.2 of [[!USB31]].

A <dfn>USB device</dfn> has a single <a>device descriptor</a> which links to
one or more <a>configuration descriptors</a>. It's <dfn>vendor ID</dfn> is
assigned to the device manufacturer by the USB-IF and is stored in the
<code>idVendor</code> field of the <a>device descriptor</a>. It's <dfn>product
ID</dfn> is assigned by the manufacturer and is stored in the
<code>idProduct</code> field of the <a>device descriptor</a>. It's <dfn>serial
number</dfn> is an optional property that is defined if the
<code>iSerialNumber</code> field of the <a>device descriptor</a> is not equal
to <code>0</code> and is the <a>string descriptor</a> referred to by that index.

# Appendix: A Brief Introduction to USB # {#appendix-intro}

<em>This section is non-normative</em>.

USB is a network but it's very different from traditional TCP/IP networks. It is
really more like an RPC system. All traffic is directed by the host, that is,
your computer. Though some devices like smartphones can act as both a USB host
and USB client they can only take on one role at a time.

## Descriptors ## {#appendix-descriptors}

USB devices identify themselves to the host by providing a set of binary
structures known as <a>descriptors</a>. The first one read by the host is the
<a>device descriptor</a> which contains basic information such as the vendor and
product IDs assigned by the USB-IF and the manufacturer. The host may then read
the device's <a>configuration descriptor</a> which is a description of the
device's capabilities including the interfaces and endpoints it exposes. A class
can be declared at the device level or for individual interfaces. A device with
multiple interfaces providing different functions is known as a
<strong><em>composite device</em></strong>.

## Transfers ## {#appendix-transfers}

Whether data is traveling from host to device or the other way around the
transfer is always initiated by the host.
<dfn>OUT transfers</dfn> carry data from host to
device and may wait until the device acknowledges the data has been received.
<dfn>IN transfers</dfn> carry data from device to
host and may have to wait until the device has some data to send. Transfers are
executed against one of a device's endpoints and there are different kinds
depending on what type of traffic is being sent.

  * <dfn>Bulk transfers</dfn> are good for sending lots of data with whatever
    bandwidth is available. This is what is used to read and write data to USB
    mass storage devices.
  * <dfn>Interrupt transfers</dfn> offer guaranteed latency (by reserving
    bandwidth so that they can't be blocked by a large <a>bulk transfers</a>)
    but with limited packet sizes. These are used for signaling and for small
    packets like mouse movements and button presses.
  * <dfn>Isochronous transfers</dfn> also reserve
    bandwidth but they don't guarantee delivery. They're used for streaming data
    like audio and video.
  * Every device also has a special
    <dfn lt="default endpoint|default control pipe">default endpoint</dfn>. While regular
    endpoints only carry data in one direction or the other
    <a>control transfers</a> have a small header called the
    <a>SETUP packet</a> that is always sent to the device and contains request
    parameters in addition to a larger data payload that can be either IN or OUT.

<pre class="biblio">
{
  "RFC4122": {
    "href": "https://tools.ietf.org/html/rfc4122",
    "title": "A Universally Unique IDentifier (UUID) URN Namespace",
    "publisher": "Internet Engineering Task Force",
    "date": "July 2005"
  },
  "USB31": {
    "href": "http://www.usb.org/developers/docs/",
    "title": "Universal Serial Bus 3.1 Specification",
    "publisher": "USB Implementors Forum",
    "date": "26 July 2013"
  }
}
</pre>

<pre class="anchors">
spec: ECMAScript; urlPrefix: https://tc39.github.io/ecma262/#
    type: interface
        text: Array; url: sec-array-objects
        text: Promise; url:sec-promise-objects
        text: TypeError; url: sec-native-error-types-used-in-this-standard-typeerror
spec: Feature Policy; urlPrefix: https://wicg.github.io/feature-policy/#
    type: dfn
        text: default allowlist
        text: feature
        text: feature name
</pre>

<pre class="link-defaults">
spec: html
    type: dfn
        text: transient activation
        text: in parallel
        text: incumbent settings object
spec: webidl
    type: dfn
        text: resolve
</pre>
