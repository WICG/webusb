# WebUSB Explained

## What is it?
Today when you connect a device to your computer you hope that somehow it will find the right driver and it will Just Work&trade;. For lots of devices it does because there are standardized drivers for things like keyboards, mice, hard drives and webcams built into the operating system. What about the long tail of unusual devices or the next generation of gadgets that haven't been standardized yet? WebUSB takes "plug and play" to the next level by connecting devices to the software that drives them across any platform by harnessing the power of web technologies.

## What is it not?
WebUSB does not attempt to provide a general mechanism for any web page to connect to any USB device. Historically USB hosts and devices have trusted each other too much to let arbitrary pages connect to them. There are published attacks against USB devices that will accept unsigned firmware updates that cause them to become malicious and attack the host they are connected to; exploiting the trust relationship in both directions.

Instead USB devices will be associated with a web origin and can only be connected to from a page from the same origin. New devices (or firmware updates) may include a list of acceptable origins that the user agent can query, similar to the CORS mechanism for HTTP requests. Device vendors may enable existing devices by registering them in an open directory mapping device IDs to acceptable origins.

## An example: Web support for 3-D printers
3D printers are all the rage these days but you can’t go on Thingiverse and hit `Ctrl-P` to print out any of the designs because user agents and the operating systems they run on have not implemented 3-D printer support.

First, a manufacturer like MakerBot can build their device setup and calibration software directly into their website. When the excited new user plugs the USB cable into their computer they are greeted by a friendly notification, “MakerBot Replicator II detected. Go to setup.makerbot.com/replicator2 to connect.” When they visit this site it will ask for permission to connect to their new printer and can then guide them through the rest of the setup and calibration process.

On Thingiverse all they need to do to support MakerBot printers is include an `<iframe>` tag that loads a page from `https://api.makerbot.com`. This origin is also on the printer’s list of approved sites. The two origins, `https://www.thingiverse.com` and `https://api.makerbot.com` remain isolated because the browser doesn’t allow a top-level frame to modify the content of a 3rd party iframe. Thingiverse can, however use Window.postMessage() to communicate with it. The MessageEvent received by the "driver iframe" contains the unforgeable origin of the message, which allows the driver to implement any authorization scheme it would like. This mechanism would likely be encapsulated in a Javascript library that can be included by the web app to create the iframe and wrap the messaging interface in a friendlier API.

WebUSB thus replaces native code and native SDKs with cross-platform hardware support and web-ready libraries.

## Appendix: A Brief Introduction to USB
USB is a network but it's very different from traditional TCP/IP networks. It is really more like an RPC system. All traffic is directed by the *host*, that is, your computer. Though some devices like smartphones can act as both a USB host and USB client they can only take on one role at a time.

### Descriptors
USB devices identify themselves to the host by providing a set of binary structures known as descriptors. The first one read by the host is the *device descriptor* which contains basic information such as the vendor and product IDs assigned by the USB-IF and the manufacturer. The host may then read the device's *configuration descriptor* which is a description of the device's capabilities including the *interfaces* and *endpoints* it exposes. A class can be declared at the device level or for individual interfaces. A device with multiple interfaces providing different functions is known as a *composite device*.

### Transfers
Whether data is traveling from host to device or the other way around the transfer is always initiated by the host. *OUT* transfers carry data from host to device and may wait until the device acknowledges the data has been received. *IN* transfers carry data from device to host and may have to wait until the device has some data to send. Transfers are executed against one of a device's *endpoints* and there are different kinds depending on what type of traffic is being sent. *Bulk* transfers are good for sending lots of data with whatever bandwidth is available. This is what is used to read and write data to USB mass storage devices. *Interrupt* transfers offer guaranteed latency (by reserving bandwidth so that they can't be blocked by a large bulk transfers) but with limited packet sizes. These are used for signaling and for small packets like mouse movements and button presses. *Isochronous* transfers also reserve bandwidth but they don't guarantee delivery. They're used for streaming data like audio and video. Every device also has a special *control* endpoint. While regular endpoints only carry data in one direction or the other *control* transfers have a small header that is always sent to the device and contains request parameters in addition to a larger data payload that can be either IN or OUT.
